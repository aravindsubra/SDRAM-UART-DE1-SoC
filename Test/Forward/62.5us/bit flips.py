import numpy as np

# Dataset from 62.5μs refresh per row test
data = [
    (0xC, 0xC),
    (0x1C, 0xFFFF),
    (0x71, 0x0),
    (0x73, 0xFF),
    (0x7C, 0x7C00),
    (0xA0, 0x0),
    (0xA1, 0xB),
    (0xA2, 0xFF),
    (0xA4, 0xDA6D),
    (0xCE, 0x0),
    (0xCF, 0x2),
    (0xD7, 0x303),
    (0xDD, 0x0),
    (0xDE, 0x1F03),
    (0xDF, 0x0),
    (0xE0, 0x203),
    (0xE8, 0x0),
    (0xF3, 0x13),
    (0xF5, 0x300),
    (0x1B0, 0xB00),
    (0x1F2, 0x1B09),
    (0x232, 0x200),
    (0x245, 0xFB5B),
    (0x262, 0x85),
    (0x263, 0xFFFF),
    (0x2B1, 0x3),
    (0x2B4, 0x300),
    (0x2B5, 0x302),
    (0x2B8, 0x3),
    (0x2B9, 0x1B03),
    (0x3AC, 0x3),
    (0x3B1, 0x1B02),
    (0x5E9, 0xFFFF),
    (0x622, 0xFFFF)
]

# Constants
PATTERN = 0xFFFF
TOTAL_ADDRESS_SPACE = 0x09FF + 1  # Address space from 0x0000 to 0x09FF (4096 locations)

# Bit flip calculation
bit_flips = [bin(val ^ PATTERN).count('1') for _, val in data]
bit_flip_sum = sum(bit_flips)

# Compute average over full address space
average_bit_flips = bit_flip_sum / TOTAL_ADDRESS_SPACE

# Output result
print(f"--- 62.5μs Refresh Analysis ---")
print(f"Total addresses in range: {TOTAL_ADDRESS_SPACE}")
print(f"Tested addresses: {len(data)}")
print(f"Total bit flips observed: {bit_flip_sum}")
print(f"Average bit flips per address (across all memory): {average_bit_flips:.6f}")
